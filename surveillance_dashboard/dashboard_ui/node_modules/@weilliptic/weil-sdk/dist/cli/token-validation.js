import { z } from 'zod';
function isOk(result) {
    return 'Ok' in result;
}
function isErr(result) {
    return 'Err' in result;
}
function ok(value) {
    return {
        Ok: value,
    };
}
function err(value) {
    return {
        Err: value,
    };
}
const Schema = {
    U8: z
        .number()
        .gte(0, 'Number is less than 8-bit unsigned integer allows')
        .lte(2 ** 8 - 1, 'Number is more than 8-bit unsigned integer allows'),
    U16: z
        .number()
        .gte(0, 'Number is less than 16-bit unsigned integer allows')
        .lte(2 ** 16 - 1, 'Number is more than 16-bit unsigned integer allows'),
    U32: z
        .number()
        .gte(0, 'Number is less than 32-bit unsigned integer allows')
        .lte(2 ** 32 - 1, 'Number is more than 32-bit unsigned integer allows'),
    U64: z
        .bigint()
        .gte(0n, 'Number is less than 64-bit unsigned integer allows')
        .lte(2n ** 64n - 1n, 'Number is more than 64-bit unsigned integer allows'),
    Uint: z
        .number()
        .gte(0, 'Number is less than unsigned integer allows')
        .lte(Number.MAX_SAFE_INTEGER, 'Number is more than unsigned integer allows'),
    I8: z
        .number()
        .gte(-(2 ** 7), 'Number is less than 8-bit signed integer allows')
        .lte(2 ** 7 - 1, 'Number is more than 8-bit signed integer allows'),
    I16: z
        .number()
        .gte(-(2 ** 15), 'Number is less than 16-bit signed integer allows')
        .lte(2 ** 15 - 1, 'Number is more than 16-bit signed integer allows'),
    I32: z
        .number()
        .gte(-(2 ** 31), 'Number is less than 32-bit signed integer allows')
        .lte(2 ** 31 - 1, 'Number is more than 32-bit signed integer allows'),
    I64: z
        .bigint()
        .gte(-(2n ** 63n), 'Number is less than 64-bit signed integer allows')
        .lte(2n ** 63n - 1n, 'Number is more than 64-bit signed integer allows'),
    Int: z
        .number()
        .gte(Number.MIN_SAFE_INTEGER, 'Number is less than signed integer allows')
        .lte(Number.MAX_SAFE_INTEGER, 'Number is more than signed integer allows'),
    Bool: z.boolean(),
    String: z.string(),
    List: z.array(z.any()), // Validate an array of any type
    Tuple: z.tuple([z.any(), z.any()]), // Example tuple of two elements, can be adjusted for different tuple structures
    Dict: z.record(z.string(), z.any()), // Validate a dictionary with string keys and any type for values
    Record: z.record(z.string(), z.any()), // Similar to Dict, a record with string keys and any values
    // Enum: z.enum(['Value1', 'Value2', 'Value3']), // Example enum, replace with actual values
    Generic: z.any(), // A generic type, essentially allows any value
    Unknown: z.unknown(),
    Void: z.void(),
};
export const Token = ((wallet, contractAddress) => ({
    name: async () => {
        const resultSchema = Schema.String;
        const result = await wallet.contracts.execute(contractAddress, 'name', {});
        return ok(resultSchema.parse(result));
    },
    symbol: async () => {
        const resultSchema = Schema.String;
        const result = await wallet.contracts.execute(contractAddress, 'symbol');
        return ok(resultSchema.parse(result));
    },
    decimals: async () => {
        const resultSchema = Schema.U8;
        const result = await wallet.contracts.execute(contractAddress, 'decimals');
        return ok(resultSchema.parse(result));
    },
    details: async () => {
        const resultSchema = z.object({
            name: Schema.String,
            symbol: Schema.String,
            decimals: Schema.U8,
        });
        const result = await wallet.contracts.execute(contractAddress, 'details');
        return ok(resultSchema.parse(result));
    },
    total_supply: async () => {
        const resultSchema = Schema.Uint;
        const result = await wallet.contracts.execute(contractAddress, 'total_supply');
        return ok(resultSchema.parse(result));
    },
    balance_for: async (addr) => {
        const paramsSchema = z.object({
            addr: Schema.String,
        });
        const resultSchema = Schema.Uint;
        const result = await wallet.contracts.execute(contractAddress, 'balance_for', paramsSchema.parse({
            addr,
        }));
        return ok(resultSchema.parse(result));
    },
    allowance: async (owner, spender) => {
        const paramsSchema = z.object({
            owner: Schema.String,
            spender: Schema.String,
        });
        const resultSchema = Schema.Uint;
        const result = await wallet.contracts.execute(contractAddress, 'allowance', paramsSchema.parse({
            owner,
            spender,
        }));
        return ok(resultSchema.parse(result));
    },
    transfer: async (to_addr, amount) => {
        const paramsSchema = z.object({
            to_addr: Schema.String,
            amount: Schema.Uint,
        });
        const resultSchema = Schema.Void;
        const result = await wallet.contracts.execute(contractAddress, 'transfer', paramsSchema.parse({
            to_addr,
            amount,
        }));
        return ok(resultSchema.parse(result));
    },
    transfer_from: async (from_addr, to_addr, amount) => {
        const paramsSchema = z.object({
            from_addr: Schema.String,
            to_addr: Schema.String,
            amount: Schema.Uint,
        });
        const resultSchema = Schema.Void;
        const result = await wallet.contracts.execute(contractAddress, 'transfer_from', paramsSchema.parse({
            from_addr,
            to_addr,
            amount,
        }));
        return ok(resultSchema.parse(result));
    },
    approve: async (spender, value) => {
        const paramsSchema = z.object({
            spender: Schema.String,
            value: Schema.Uint,
        });
        const resultSchema = Schema.Void;
        const result = await wallet.contracts.execute(contractAddress, 'approve', paramsSchema.parse({
            spender,
            value,
        }));
        return ok(resultSchema.parse(result));
    },
}));
//# sourceMappingURL=token-validation.js.map
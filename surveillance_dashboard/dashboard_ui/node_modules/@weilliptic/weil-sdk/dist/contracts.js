import { ZodVoid } from 'zod';
import { WeilError } from './errors.js';
import { parseSchema } from './schema.js';
export function Ok(success) {
    return { Ok: success };
}
export function Err(err) {
    return { Err: err };
}
export function parseExecutionResultToAnyObject(result) {
    if (result.status !== 'Finalized') {
        if ('txn_result' in result && typeof result.txn_result === 'string') {
            let errorDetails;
            if (typeof result.txn_result === 'string') {
                errorDetails = result.txn_result;
            }
            else {
                const response = JSON.parse(result.txn_result);
                if ('Err' in response) {
                    try {
                        errorDetails = JSON.stringify(response.Err);
                    }
                    catch (e) {
                        errorDetails = response.Err?.toString();
                    }
                }
            }
            if (errorDetails) {
                throw new WeilError(`Transaction resulted in error: ${errorDetails}`, {
                    type: 'ExecutionFailure',
                    code: 'transaction-error',
                });
            }
        }
        if ('message' in result && typeof result.message === 'string') {
            throw new WeilError(`Transaction resulted in error: ${result.message}`, {
                type: 'ExecutionFailure',
                code: 'transaction-error',
            });
        }
        if ('Error' in result && typeof result.Error === 'string') {
            throw new WeilError(`Transaction resulted in error: ${result.Error}`, {
                type: 'ExecutionFailure',
                code: 'transaction-error',
            });
        }
        throw new WeilError(`Transaction failed with status ${result.status}`, {
            type: 'ExecutionFailure',
            code: 'transaction-failed-status',
        });
    }
    const response = JSON.parse(result.txn_result);
    if (!('Ok' in response)) {
        if ('Err' in response) {
            let errorDetails;
            try {
                errorDetails = JSON.stringify(response.Err);
            }
            catch (e) {
                errorDetails = response.Err?.toString();
            }
            throw new WeilError(`Transaction resulted in error: ${errorDetails}`, {
                type: 'ExecutionFailure',
                code: 'transaction-error',
            });
        }
        else {
            throw new WeilError(`Transaction result doesn't contain either 'Ok' or 'Err' fields`, {
                type: 'ExecutionFailure',
                code: 'transaction-response-format',
            });
        }
    }
    // validate response
    return JSON.parse(response.Ok);
}
export function parseExecutionResult(result, schema) {
    // validate response
    const parsedResult = parseExecutionResultToAnyObject(result);
    // for void schema, allow other return types
    if (schema instanceof ZodVoid) {
        return null;
    }
    return parseSchema(schema, parsedResult);
}
//# sourceMappingURL=contracts.js.map
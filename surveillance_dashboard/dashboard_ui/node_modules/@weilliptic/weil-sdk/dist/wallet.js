import axios, { isAxiosError } from 'axios';
import { constructRestEndpoint, constructTransactionEndpoint, defaultTransport, formatPayloadForPrint, gzip, } from './utils/index.js';
import { WeilError } from './errors.js';
import { createContractAddress, decodeContractAddress } from './utils/contract.js';
import { getSignature, } from './transactions/signature.js';
import { sha256 } from '@noble/hashes/sha2.js';
import { addressFromPublicKey, getUncompressedPublicKey } from './utils/keys.js';
import base32Encode from 'base32-encode';
import { WeilWalletCommon, } from './walletCommon.js';
import { bytesToHex } from '@noble/hashes/utils.js';
let debugLog = console.log.bind(console);
const isDebug = false;
if (!isDebug) {
    debugLog = (...args) => undefined;
}
async function* convertIterable(iterable) {
    for await (const chunk of iterable) {
        const decoder = new TextDecoder();
        yield decoder.decode(chunk);
    }
}
async function executeStreamNode(endpoint, gzippedPayload) {
    const formData = new FormData();
    formData.append('transaction', new Blob([gzippedPayload], { type: 'application/octet-stream' }));
    const response = await axios.post(endpoint, formData, {
        responseType: 'stream',
    });
    return convertIterable(response.data);
}
const sendTransactionViaTransport = async (endpoint, payload, headers = {}, transport = 'multipart') => {
    const formData = new FormData();
    let body = formData;
    if (transport === 'multipart') {
        const gzippedPayload = await gzip(JSON.stringify(payload));
        formData.append('transaction', new Blob([gzippedPayload], { type: 'application/octet-stream' }));
    }
    else {
        body = JSON.stringify(payload);
    }
    debugLog(`sending a POST request (${transport})`, new Date());
    if (transport === 'post') {
        headers['content-type'] = 'application/json';
    }
    return await fetch(endpoint, {
        method: 'POST',
        body,
        headers,
    });
};
const executeStream = async (endpoint, payload, headers, transport = defaultTransport) => {
    const response = await sendTransactionViaTransport(endpoint, payload, headers, transport);
    if (!response.body) {
        throw new Error('No response body!');
    }
    debugLog('got POST stream response', new Date());
    const reader = response.body.getReader();
    debugLog('got reader', new Date());
    return (async function* convertReader() {
        let done = false;
        let value;
        debugLog('before while loop in reader', new Date());
        let firstChunk = true;
        while (!done) {
            ;
            ({ done, value } = await reader.read());
            if (firstChunk) {
                firstChunk = false;
                debugLog('got first chunk');
            }
            if (value) {
                const decoder = new TextDecoder();
                const decoded = decoder.decode(value, { stream: true });
                yield decoded;
            }
            if (done) {
                break;
            }
        }
    })();
};
const execute = async (endpoint, payload, headers, contractAddress, transactionId, transport = defaultTransport) => {
    try {
        const response = await sendTransactionViaTransport(endpoint, payload, headers, transport);
        const responseData = await response.json();
        return {
            ...responseData,
            contract_address: contractAddress,
            transaction_id: transactionId,
        };
    }
    catch (error) {
        if (isAxiosError(error)) {
            if (error.response?.data instanceof Object &&
                typeof error.response.data.message === 'string') {
                error.message = error.response.data.message;
            }
            else {
                throw error;
            }
        }
        throw error;
    }
};
export const isAsyncIterable = (value) => {
    return Boolean(value[Symbol.asyncIterator]);
};
export class WeilWallet extends WeilWalletCommon {
    config;
    constructor(options) {
        super();
        this.config = {
            ...options,
            transport: options.transport || defaultTransport,
        };
    }
    async getAxiosInstance() {
        if (!this._axiosInstance) {
            this._axiosInstance = axios.create({
                baseURL: constructRestEndpoint(this.config.sentinelEndpoint),
            });
        }
        return this._axiosInstance;
    }
    getTransactionId(podCounter, signature) {
        const id = sha256(signature);
        const data = new Uint8Array(4 + id.length);
        new DataView(data.buffer).setUint32(0, podCounter);
        data.set(id, 4);
        return base32Encode(data, 'RFC4648', { padding: false }).toLowerCase();
    }
    async submitTransaction(params) {
        const { toAddress, contract, headers } = params;
        const { sentinelEndpoint, transport, privateKey } = this.config;
        const publicKey = getUncompressedPublicKey(privateKey);
        const fromAddress = addressFromPublicKey(publicKey);
        let targetPodCounter;
        if (params.contract.type === 'SmartContractExecutor') {
            const contractMetaInfo = decodeContractAddress(params.contract.address);
            targetPodCounter = contractMetaInfo.counter;
        }
        else {
            // deploy path
            const podId = params.contract.pod;
            const pods = await this.pods.list();
            targetPodCounter = pods.find(pod => pod.podId === podId)?.counter;
        }
        const creationTime = new Date().getTime();
        const nonce = params.nonce ?? creationTime;
        let userTransaction;
        let contractAddress;
        switch (contract.type) {
            case 'SmartContractExecutor':
                contractAddress = contract.address;
                userTransaction = {
                    contract_address: contractAddress,
                    contract_input_bytes: JSON.stringify(contract.arguments),
                    contract_method: contract.method,
                    type: contract.type,
                };
                break;
            case 'SmartContractCreator':
                contractAddress = createContractAddress(publicKey, nonce, targetPodCounter);
                // important to keep props sorted alphabetically
                userTransaction = {
                    contract_body: contract.body,
                    init_args: contract.init_args || JSON.stringify({ values: '' }),
                    // is_audit_log_enabled: contract.auditLog,
                    // is_outcall_enabled: contract.outcall,
                    smart_contract_header_metadata: {
                        author: contract.author || null,
                        contract_address: contractAddress,
                        contract_body_len: contract.body.length / 2,
                        contract_config: contract.config || null,
                        contract_context: contract.context || null,
                        contract_widl: contract.widl,
                        description: contract.description || null,
                        logo: contract.logo || null,
                        name: contract.name || null,
                        organization: contract.organization || null,
                        upgrade_contract: contract.upgrade,
                    },
                    type: contract.type,
                };
                break;
            default:
                throw new WeilError('Invalid contract type');
        }
        const signableTransaction = {
            from_addr: fromAddress,
            nonce: Number(nonce),
            to_addr: toAddress,
            user_txn: userTransaction,
        };
        debugLog('getting signature for', signableTransaction);
        const signature = getSignature(signableTransaction, this.config.privateKey);
        debugLog('this signature is', bytesToHex(signature));
        if (contract.type === 'SmartContractCreator') {
            const userTxn = signableTransaction.user_txn;
            userTxn.is_audit_log_enabled = contract.auditLog;
            userTxn.is_outcall_enabled = contract.outcall;
        }
        let payload = {
            transaction: {
                is_xpod: false,
                txn_header: {
                    from_addr: fromAddress,
                    nonce: Number(nonce),
                    public_key: publicKey,
                    to_addr: toAddress,
                    signature: bytesToHex(signature),
                    weilpod_counter: targetPodCounter,
                    creation_time: creationTime,
                },
                user_txn: userTransaction,
                verifier: {
                    type: 'DefaultVerifier',
                },
            },
        };
        const transactionId = this.getTransactionId(targetPodCounter, signature);
        const endpoint = constructTransactionEndpoint(sentinelEndpoint, contract.type, transport);
        debugLog(`Submitting to ${endpoint}`);
        debugLog(formatPayloadForPrint(payload));
        switch (contract.type) {
            case 'SmartContractCreator':
                const gzippedPayload = await gzip(JSON.stringify(payload));
                const deployResult = await axios.postForm(endpoint, {
                    transaction: gzippedPayload,
                }, {
                    headers,
                });
                return {
                    contract_address: contractAddress,
                    ...deployResult.data,
                };
            case 'SmartContractExecutor':
                if (params.stream) {
                    return executeStream(endpoint, payload, headers, transport);
                }
                return execute(endpoint, payload, headers, contractAddress, transactionId, transport);
            default:
                throw new WeilError(`Invalid contract type`);
        }
    }
    transactions = {
        submit: async (params) => {
            return this.submitTransaction(params);
        },
    };
}
//# sourceMappingURL=wallet.js.map